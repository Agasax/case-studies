---
title: "Semantics for the Stan probabilistic programming language"
author: "Bob Carpenter"
date: "March 2020"
output:
  tufte::tufte_html:
    toc: false
    toc_depth: 1
---

```{r, echo = FALSE, message = FALSE, warning = FALSE}
library(tufte)

knitr::opts_chunk$set(
  include = TRUE,  cache = FALSE,  collapse = TRUE,  echo = TRUE,
  message = FALSE, tidy = FALSE,  warning = FALSE,   comment = "  ",
  dev = "png", dev.args = list(bg = '#FFFFF8'), dpi = 300,
  fig.align = "center",  fig.width = 7,  fig.asp = 0.618,  fig.show = "hold",
  out.width = "90%")
```

## Abstract {-}

<small>
Fe, fi, fo, fum.
</small>

<small>
*Keywords:* probabilistic programming, statistical inference,
programming language semantics
</small>



# Introduction

This paper introduces a denotational and operational semantics for Stan,
a differentiable probabilistic programming language.

## About Stan

Stan is a domain-specific imperative programming language for
statistical models.  Stan is a *probabilistic programming language* in
the sense that programs define log posteriors or log likelihoods and
variables representing unknowns behave as random variables during
inference.  Stan is a *differentiable programming language* in the
sense that it a Stan program defines a generic log density function
that is smooth and may be applied to automatic differentiation
variables.

Stan is strongly statically typed.  Variables at program scope are
partitioned according to whether they are 

* known quantities (e.g., constants and observed data),
* unkown quantities (e.g., model parameters and missing data),
* transformed variables (e.g., transforms of data or parameters), or
* generated quantities (e.g., predictions and event probabilities).

Statements are used to update a target log density, which represents
the log density of the parameters (unknown variables) conditioned on data
(known variables), and to define the transformed variables and
generated quantities.

The full range of control flow is available including conditionals,
for and while loops, and recursive user-defined functions.  Local
variables may be used at block scope and in function arguments.


## Stan reference implementation

Stan was designed, built and put into production before it was
formally specified.  The [Stan Reference Manual
(v2.23)](https://mc-stan.org/docs/2_23/reference-manual/index.html)
informally describes the concrete syntax and semantics of the
reference implementation.  The goal of this paper is to precisely
codfiy the semantics of the Stan language.  As such, it is intended to
be consistent with the existing reference implementation.

In its reference implementation, Stan is translated to C++ to produce
a class definition with a constructor that reads and stores the data
immutably, along with a templated log density method that may be
automatically differentiated.  The reference implementation is backed
by several state-of-the-art forms of inference that rely on gradients
and Hessians: adaptive Hamiltonian Monte Carlo for Bayesian inference,
gradient-based variational methods for approximate Bayesian inference,
and quasi-Newton optimization methods for point estimation with
bootstrap uncertainty or Laplace approximation.^[There have been two
implementations of the Stan language.  The first, coded in C++ using
the Boost Spirit Qi framework, only targeted the Stan math library for
output.  The second, coded in OCaml using the Menhir framework, has a
code generator for the Stan math library and a prototype code
generator for TensorFlow Probability.]


## Stepwise approach

The paper begins with an overview of the simplest meaningful fragment
of Stan, which consists of unconstrained real-valued data variables,
parameter variables, and sampling statements.^[Not coincidentally,
this was also the first functionality implemented in the Stan language
parser, abstract syntax tree, and code generator.]

The second sublanguage adds local variables and assignment statements,
along with transformed data and transformed parameter variables.

The third sublanguage adds data types for integers,
matrices and vectors, and arrays of arbitrary dimension.

The fourth sublanguage adds control flow in the form of loops and
conditionals.^[At this point, the full range of BUGS control flow and
more is available.]

The fifth sublanguage adds constrained variable types, such as
positive-constrained variables, simplexes, or covariance matrices.
Each constrained type is associated with a smooth, monotonic
transform.  Stan automatically applies the change-of-variables
adjustment for the constraining transform.^[At this point, BUGS models
that do not involve integer parameters may be translated directly to
Stan.]

The sixth sublanguage adds a generated quantities block for posterior
predictive quantities defined as transforms and random generation from
data and parameters.

The seventh sublanguage adds user-defined functions and
closures.^[Stan uses simple higher-order types and thus cannot suppor
the rich parametric polymorphism found in languages like ML.]

Parallel computation and the use of GPUs is handled in the target
generated code rather than in the language.


# Overview


# MiniStan Sequent Calculus

## Objects

\[
L \in \textsf{NumericLiteral}
\]

$$
V \in \textsf{Variable}
$$

$$
T \in \textsf{Type} ::= \texttt{real}
$$

$$
D \in \textsf{Declaration}
\ \begin{array}[t]{rl}
::=  & \epsilon
\\
\mid & V : T
\\
\mid & D_1, D_2
\end{array}
$$

$$
E \in \textsf{Expression}
\
\begin{array}[t]{rl}
::=  & L \\
\mid & V \\
\mid & F(E_1, \ldots, E_n) \quad [n \geq 0]
\end{array}
$$


$$
S \in \textsf{Statement}
\
\begin{array}[t]{rl}
::=    & \epsilon \\
\mid   & \texttt{target +=} E \\
\mid   & S_1, S_2
\end{array}
$$

$$
P \in \textsf{Program}
::=        \texttt{data}       \ \, D_1,
    \ \, \texttt{parameters} \ \, D_2,
    \ \, \texttt{model}      \ \, S
$$

$$
\Gamma \in \textsf{TypeEnvironment}
\
\begin{array}[t]{rl}
::=  &  \epsilon \\
\mid &  V : T \\
\mid &  \Gamma_1, \Gamma_2
\end{array}
$$

## Type inference

$$
\frac
  {}
  {V:T \vdash V:T}
  (1)
$$

$$
\frac
  {\Gamma_1 \vdash V:T}
  {\Gamma_1, \, \Gamma_2 \vdash V:T}
  (\textrm{2a})
\qquad
\frac
  {\Gamma_2 \vdash V:T}
  {\Gamma_1, \, \Gamma_2 \vdash V:T}
  (\textrm{2b})
$$

$$
\frac{\Gamma \vdash F:(T_1 \times \cdots \times T_N) \rightarrow T_0
      \qquad
      \Gamma \vdash E_1 : T_1
      \quad \cdots \quad
      \Gamma \vdash E_N : T_N}
     {\Gamma \vdash F(E_1, \ldots, E_N) : T_0}
     (3)
$$     
      
## Evaluation

### Expression evaluation

$$
\frac
  {}
  {N, \sigma \Downarrow n}
  (1)
$$

$$
\frac
  {\sigma(V) = v}
  {V, \sigma \Downarrow v}
  (2)
$$

$$
\frac{\sigma(F) = f
      \qquad
      E_1, \sigma \Downarrow v_1
      \quad \cdots \quad
      E_N, \sigma \Downarrow v_N}
      {F(E_1, \ldots, E_N), \sigma \Downarrow f(v_1, \ldots v_N)}
      (3)
$$

### Statement evaluation

$$
\frac
  {E, \sigma \Downarrow e}
  {\sigma, \texttt{target}\,\texttt{+=} \ E
   \Downarrow \sigma[{\small \textrm{target} = \textrm{target} + e}]}
  (1)
$$  

$$
\frac
  {}
  {\epsilon, \sigma \Downarrow \sigma}
  (2)
$$  

$$
\frac{S_1, \sigma_1 \Downarrow \sigma_2
      \qquad
      S_2, \sigma_2 \Downarrow \sigma_3}
      {(S_1, S_2), \sigma_1 \Downarrow \sigma_3}
      (3)
$$      

### Declaration evaluation

$$
\frac
  {}
  {\Gamma, \epsilon \vdash \Gamma}
  (1)
$$

$$
\frac
  {\Gamma_1, D_1 \Downarrow \Gamma_2
   \qquad
   \Gamma_2, D_2 \Downarrow \Gamma_3}
  {\Gamma_1, (D_1, D_2) \Downarrow \Gamma_3}
  (2)
$$

$$
\frac
  {}
  {V{:}T, \Gamma_1 \Downarrow V{:}T, \Gamma_1}
  (3)
$$

### Program evaluation




# MiniStan

The design of Stan was strongly influenced by the design of BUGS.
In this section, a simple BUGS-like version of Stan is defined
that is simpler still in that it only involves univariate variables
and does not introduce local variables.  This section lays out
MiniStan in the same form as the more general Stan is layed out in the
rest of the document.

All expressions in MiniStan denote single real quantities, so the set of
types is the singleton
$$
\textsf{Type} = \{ \texttt{real} \}.
$$

Each type has a range of values expressions of that type may have.  In
MiniStan, there is only one type, expressions of which take values in
the set $\textsf{Value}_{\textt{real}}$.  The Stan language is
polymorphic by design and can work with value types including
floating point and automatic differentiation variables.

MiniStan includes a countably infinite set of variables.  For
concreteness, and to match Stan's notion of identifier, let
$$
\textsf{Variable} = \texttt{a-ZA-Z(a-zA-Z0-9_)*}.
$$

There is only one type, $\texttt{real}$, which is used for every
variable.  The variable typing function $\textrm{type} :
\textsf{Variable} \rightarrow \textsf{Type}$ is thus constant, so that
$$
\textrm{type}(v) = \texttt{real}
$$
for every $v \in \textsf{Variable}$.

Expressions are mathematical formulas made up of constants, variables,
and functions that denote values.  In MiniStan, the set
\textsf{Expression} is defined to be the smallest such that

* $y \in \textsf{Expression}$ if $y \in \mathsf{Value}_{\texttt{real}}$,
* $v \in \textsf{Expression}$ if $v \in \textsf{Variable}$, and
* $f(e_1, \ldots, e_N) \in \textsf{Expression}$ if
  $f : \textsf{real}(
          \underbrace{\textsf{real}, \ldots, \textsf{real}}
                     _{N \ \textrm{times}})$,
  and $e_1, \ldots, e_N \in \textsf{Expression}.$

In practice, values cannot be used directly and must be expressed
using a literal syntax, such as standard computational scientific
notation for real numbers (e.g., `-1.3e-12` for $-1.3 \times
10^{-12}$), which is then translated into the value type.

An environment is a mapping from variables to values, which for
MiniStan reduces to a simple function
$\Gamma : \textsf{Variable}_{\texttt{real}}
          \rightarrow \textsf{Value}_{\texttt{real}}$.

Expressions have denotations in their value types relative to an
environment $\Gamma$, defined by

* ${}_{\Gamma}[\![ y ]\!] = y$
  if $y \in \textsf{Value}_{\texttt{real}}$,
* ${}_{\Gamma}[\![ v ]\!] = \Gamma(v)$
  if $v \in \textsf{Variable}_{\texttt{real}}$, and
* ${}_{\Gamma}[\![ f(e_1, \ldots, e_N)]\!]
   = f'({}_{\Gamma}[\![ e_1 ]\!], \ldots
        {}_{\Gamma}[\![ e_N ]\!])$ where
  $f' : \textsf{Value}_{\texttt{real}}^N \rightarrow
        \textsf{Value}_{\texttt{real}}$ is the denotation of $f$

MiniStan is restricted to sampling statements.  The set
$\textsf{Statement}$ of statements is the smallest such that

* $e_0 \sim f(e_1, \ldots, e_N)\texttt{;} \in \textsf{Statement}$
  if $e_0, e_1, \ldots, e_N \in \textsf{Expression}_{\texttt{real}}$
  and $f' : (\textsf{Value}_{\texttt{real}})^{N + 1} \rightarrow
        \textsf{Value}_{\texttt{real}}.$

The other content of a MiniStan program is a variable
declaration.  The set $\textsf{Declaration}$ of variable declarations
is the least such that

* $\texttt{real} \ v\texttt{;} \in \textsf{Declaration}$ if $v \in
  \textsf{Variable}$.

A MiniStan program consists of three blocks,

* a data block declaring variables that are known and read in
externally,
* a parameters block declaring parameters that are unknown and for
which inference is desired, and
* a model block defining a log density.

The set $\textsf{Program}$ is the smallest such that

* $\texttt{data \{} d_1, \ldots, d_M \texttt{\}}$
  $\texttt{parameters \{} u_1, \ldots, u_N \texttt{\}}$
  $\ \texttt{model \{} s_1, \ldots, s_J \texttt{\}}
   \in \textsf{Program}$ if
 $d_1, \ldots d_M \in \textsf{Declaration}$,
 $u_1, \ldots u_N \in \textsf{Declaration}$,
 $s_1, \ldots s_J \in \textsf{Statement}$,
 no variable is declared more than once, and every variable
 used in the model block is declared.

The denotation of a MiniStan program $p \in \textsf{Program}$ is a
function
$$
[\![p]\!]: \mathsf{Value}_{\texttt{real}}^M
  \rightarrow
  (\mathsf{Value}_{\texttt{real}}^N \rightarrow
\mathbb{R})
$$
that maps a data vector $y$ to a log density function $[\![ p
]\!](y)$, which in turn maps a parameter vector $\theta$ to a log
density $[\![ p ]\!](y)(\theta)$.  Letting $\pi$ be the posterior
density for parameters $\theta$ given data $y$, the denotation of a
Stan program is
$$
[\![ p ]\!](y)(\theta) = \log \pi(\theta \mid y) + \textrm{const.},
$$
where $\textrm{const}$ does not depend on $\theta$.

An environment is a mapping from variables to values.  Given $y \in
\mathbb{R}^M$ and $\theta \in \mathbb{R}^N$, define an environment
$\Gamma$ such that
$$
\Gamma_{y,\theta}(v)
=
\begin{cases}
y_m & \textrm{if} \ d_m = \texttt{real} \ v;
\\[4pt]
\theta_n & \textrm{if} \ u_n = \texttt{real} \ v;
\\[4pt]
\textrm{undefined} & \textrm{otherwise}.
\end{cases}
$$

A MiniStan program $p$ has a denotation $[\![ p ]\!]$ defined by
$$
[\![ p ]\!](y, \theta) = \sum_{j = 1}^J {}_{\Gamma_{y,\theta}}[\![ s_j ]\!],
$$
where the $j$-th statement in the program block is
$$
s_j = e_{j, 0} \sim f(e_{j, 1}, \ldots, e_{j, K_j})
$$
and its contribution to the log density is given by
$$
\Gamma_{y,\theta}[\![ s_j ]\!]
=
\Gamma_{y,\theta}[\![ \, f_j(e_{j, 0}, e_{j, 1}, \ldots, e_{j, K_j}) ]\!].
$$

In Bayesian applications, given a fixed data set $y$, the posterior
log density function $[\![ p ]\!](y)$ can be used with a sampler to
draw a posterior sample
$$
\theta^{(1)}, \ldots, \theta^{(S)} \sim \pi(\theta \mid y),
$$
or with an optimizer to find a posterior mode,
$$
\theta^* = \textrm{arg max}_{\theta} \ \pi(\theta \mid y).
$$
With automatic differentiation variables for $\theta$, gradient-based
algorithms like Hamiltonian Monte Carlo sampling and limited-memory
quasi-Newton optimization can be used, because it is relatively
inexpensive to accurately compute $\nabla_{\theta} \log p(\theta \mid
y)$.


# Stan

## Types

Every variable in Stan is declared with a type that is known
statically.  From the types of variables, the type of an expression
may be inferred.

In addition to function types, there are three classes of types in
Stan:

* basic types, used for function argument declarations,
* sized types, used for local variable declarations, and
* constrained types, used for block variable declarations.

The set $\textsf{BasicType}$ is the least such that

* $\texttt{real}, \texttt{int} \in \textsf{BasicType}$,
* $\texttt{vector}, \texttt{row_vector}, \texttt{matrix} \in
  \textsf{BasicType}$, and
* $T[] \in \textsf{BasicType}$ if $T \in \textsf{BasicType}$.

The number of dimensions of a type is given by the function
$\textrm{dim}:\textsf{BasicType} \rightarrow \mathbb{N}$ defined
inductively by

* $\textrm{dim}(\texttt{real})
   = \textrm{dim}(\texttt{int})
   = 0$
* $\textrm{dim}(\texttt{vector})
   = \textrm{dim}(\texttt{row_vector})
   = 1$,
* $\textrm{dim}(\texttt{matrix}) = 2$, and
* $\textrm{dim}(T[]) = 1 + \textrm{dim}(T)$.

The set $\textsf{SizedType}$ is the least such that

* $\texttt{real}, \texttt{int} \in \textsf{SizedType}$,
* $\texttt{vector}[n] \in \textsf{SizedType}$ if $n \in \mathbb{N}$,
* $\texttt{row_vector}[m] \in \textsf{SizedType}$ if $m \in \mathbb{N}$,
* $\texttt{matrix}[m, n] \in \textsf{SizedType}$ if $m, n \in
  \mathbb{N}$, and
* $T[n] \in \textsf{SizedType}$ if $T \in \textsf{SizedType}$ and $n
  \in \mathbb{N}$.

Each sized type corresponds to the basic type derived by removing the sizes.

The set $\textsf{ConstrainedType}$ is the least such that

* $\texttt{real}, \texttt{int} \in \textsf{ConstrainedType}$,
* $\texttt{vector}[n], \texttt{unit_vector}[n]$, $\texttt{simplex}[n],
  \texttt{ordered}[n]$, $\texttt{pos_ordered}[n] \in \textsf{ConstrainedType}$
  if $n \in \mathbb{N}$,
* $\texttt{row_vector}[m] \in \textsf{ConstrainedType}$ if $m \in \mathbb{N}$,
* $\texttt{matrix}[m, n] \in \textsf{ConstrainedType}$ if $m, n \in
  \mathbb{N}$, and
* $\texttt{cov_matrix}[m], \texttt{corr_matrix}[n]$,
  $\texttt{cholesky_factor}[n]$, $\texttt{cholesky_factor_corr}[n] \in
  \textsf{ConstrainedType}$ if $m, n \in \mathbb{N}$, and
* $T[] \in \textsf{ConstrainedType}$ if $T \in \textsf{ConstrainedType}$.

Each constrained type corresponds to a sized type that is derived by
dropping the constraint.  Specifically,

* $\texttt{vector}[n]$ is the sized type for the constrained types
  $\texttt{unit_vector}[n]$,  $\texttt{simplex}[n]$,
  $\texttt{ordered}[n]$, and $\texttt{pos_ordered}[n]$; and
* $\texttt{matrix}[n, n]$ is the sized type for the constrained types
  $\texttt{cov_matrix}[m]$, $\texttt{corr_matrix}[n]$,
  $\texttt{cholesky_factor}[n]$, and $\texttt{cholesky_factor_corr}[n]$.

Stan uses simply typed functions.  The set $\textsf{FunctionType}$ is
the least such that

* $T_0(T_1, \ldots, T_N) \in \textsf{FunctionType}$ if
  $T_0, T_1, \ldots, T_N \in \textsf{FunctionType} \cup \textsf{BasicType}$.

## Variables, expressions, and type inference

Expressions are syntactic constructs that denote values.  Stan assumes
there is some computational approximation of a real-valued field (in
the algebraic sense) over which real-valued expressions take their
value.  Integers are assumed to be a subset of the real values.  In
practice, real values are representated using fixed-size floating
point numbers and fixed size integers for constants and data and
automatic differentiation variables for parameters.

The set $\textsf{Variable}$ consists of a countably infinite set of
unique identifiers.

The set $\textsf{Expression}$ is the least such that

* $y \in \textsf{Expression}$ if $y \in \mathbb{R} \cup \{ -\infty,
  +\infty, \textrm{NaN} \}$,
* $n \in \textsf{Expression}$ if $n \in \mathbb{Z}$,
* $v \in \mathsf{Expression}$ if $v \in \textsf{Variable}$, and
* $f(e_1, \ldots, e_n) \in \textsf{Expression}$ if
   $f, e_1, \ldots, e_n \in \textsf{Expression}$.

The *typing relation* $:$ is defined relative to a variable typing
function $\textrm{type} : \textsf{Variable} \rightarrow \textsf{Type}$ as the
smallest relation such that

* $y : \texttt{real}$ if $y \in \mathbb{R} \cup \{ -\infty,
  +\infty, \textrm{NaN} \}$,
* $n : \texttt{int}$ if $n \in \mathbb{Z}$,
* $v : T$ if $v \in \textsf{Variable}$ and $\textrm{type}(v) = T$
* $f(e_1, \ldots, e_n) : T_0$ if
   $f : T_0(T_1, \ldots, T_N)$ and $e_1:T_1, \ldots, e_N:T_n$.

## Values of types

Expressions take on values in a range that is determined by their
type.  The sets of possible values $\textsf{Value}_T$ for each sized
type $T \in \textsf{SizedType}$ is defined jointly by

* $\textsf{Value}_{\texttt{int}} = \mathbb{Z}$,
* $\textsf{Value}_{\texttt{real}} = \mathbb{R}$,
* $\textsf{Value}_{\texttt{vector}[n]} = \mathbb{R}^n$,
* $\textsf{Value}_{\texttt{row_vector}[m]} = \mathbb{R}^m$,
* $\textsf{Value}_{\texttt{matrix}[m, n]} = \mathbb{R}^{m \times n}$,
* $\textsf{Value}_{T[k]} = (\textsf{Value}_T)^k$, and
* $\textsf{Value}_{T_0(T_1, \ldots, T_N)}
  = (\textsf{Value}_{T_1} \times \cdots \times \textsf{Value}_{T_N})
    \rightarrow \textsf{Value}_{T_N})$.

Possible values for unsized types are the union of their sized counterparts,

* $\textsf{Value}_{\texttt{vector}[]}
  = \bigcup_{n \in \mathbb{N}} \textsf{Value}_{\texttt{vector}[n]}$
* $\textsf{Value}_{\texttt{matrix}}
  = \bigcup_{m, n \in \mathbb{N}}
    \textsf{Value}_{\texttt{matrix}[m, n]}$
* $\textsf{Value}_{T[]}
  = \bigcup_{k \in \mathbb{N}} \textsf{Value}_{T[k]}$


## Environments and expression denotations

Given an expression $e$ of type $T$, its denotation will be an element
of $\textsf{Value}_T$.  An *environment* is a function
$\Gamma: \textrm{Variable} \rightarrow \textrm{Value}$.  Relative to
an environment $\Gamma$, an expression $e$ of type $T$ has a denotation
${}_\Gamma[\![ e ]\!] \in \textrm{Value}_T$ defined by

* ${}_\Gamma[\![ y ]\!]
  = y$ if $y \in \mathbb{R} \cup \{-\infty, \infty, \textrm{NaN} \}$,
* ${}_\Gamma[\![ n ]\!]
  = n$ if $n \in \mathbb{Z}$,
* ${}_\Gamma[\![ v ]\!]
  = \Gamma(v)$ if $v \in \textsf{Variable}$, and
* ${}_\Gamma[\![ f(e_1, \ldots, e_N) ]\!]
  = {}_\Gamma[\![f]\!]({}_\Gamma[\![e_1]\!], \ldots, {}_\Gamma[\![e_N]\!])$
    if $f : T_0(T_1, \ldots, T_N)$ and $e_1 : T_1, \ldots, e_N: T_N$.

## Lvalues

Lvalues are the set of expressions that may appear on the left hand
side of an assignment statement.  The set $\textsf{Lvalue}$ is defined
to be the least such that

* $v \in \textsf{Lvalue}$ if $v \in \textsf{Variable}$ and
* $v[i_1, \ldots, i_N] \in \textsf{Lvalue}$ if $v \in
  \textsf{Variable}$, $\textrm{dim}(\textrm{type}(v)) \geq N$, and
  $i_1, \ldots, i_N \in \mathbb{N}$.

## Variable declarations

The set \textsf{Declaration} of variable declarations is the smallest
such that

* $T v \in \textsf{Declaration}$
  if $T \in \textsf{Type}$ and $v \in \textsf{Variable}$

## Statements

The set $\textsf{Statement}$ is the smallest such that

* $l = e \in \textsf{Statement}$ <br />
  if $l \in \textsf{Lvalue}_T$ and $e \in \textsf{Expression}_T$,
* $y \sim \ p(\theta_1, \ldots, \theta_N) \in \textsf{Statement}$  <br />
  if $p : \texttt{real}(T_0, T_1, \ldots, T_N),
      y : T_0, \theta_1 : T_1, \ldots, \theta_N : T_N$,
* $\{ d_1; \cdots d_M; s_1; \cdots s_N; \} \in \textsf{Statement}$  <br />
  if $d_1, \ldots, d_M \in \textsf{Declaration}$
  and $s_1, \ldots, s_N \in \textsf{Statement}$,



<br />

<br />